import { useState } from "react";
import { Storage } from "../../data/storage";
import type { Assignment, Task, User } from "../../data/types";
import { useAuth } from "../../state/auth";
import { ViewAssignmentsPdfButton } from "../../components/ViewAssignmentsPdfButton";

function id(prefix: string) {
  return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now()}`;
}

function getCreatedBy(u: User): string | undefined {
  return (u as any).createdBy as string | undefined;
}

export function AdminDashboardPage() {
    const [newUserPhone, setNewUserPhone] = useState("");
    void newUserPhone;
    void setNewUserPhone;
const { user, refresh } = useAuth();
  const [tab, setTab] = useState<"approvals" | "users" | "tasks" | "assign" | "all">("approvals");

  // read fresh each render (MVP style)
  const allUsers = Storage.getUsers();
  const tasks = Storage.getTasks();
  const assignments = Storage.getAssignments();

  if (!user) return null;

  const isAdmin = user.role === "admin";

  // ---------------- Visibility rules ----------------
  // Admin: sees everyone.
  // Manager: sees only:
  //   - themselves
  //   - employees created by them (createdBy === manager.id)
  //   - NEVER other managers/admins (except themselves)
  const visibleUsers: User[] = isAdmin
    ? allUsers
    : allUsers.filter((u) => {
        if (u.id === user.id) return true; // manager sees self
        if (u.role !== "employee") return false; // block other managers/admins entirely
        return getCreatedBy(u) === user.id; // only employees created by this manager
      });

  const pending = visibleUsers.filter((u) => u.status === "pending");
  const employees = visibleUsers.filter((u) => u.role === "employee" && u.status === "active");

  // For safety, when saving users, ALWAYS write the full array (allUsers), not visibleUsers.
  const canManageUserRecord = (target: User) => {
    if (isAdmin) return true;
    // manager can only manage employees they created; never other roles
    if (target.role !== "employee") return target.id === user.id; // manager can see self but not manage other roles
    return getCreatedBy(target) === user.id;
  };

  // ---------------- Add Employee (admin + manager) ----------------
  const [addEmp, setAddEmp] = useState<{ name: string; email: string; password: string }>({
    name: "",
    email: "",
    password: "",
  });

  const addEmployee = () => {
    const name = addEmp.name.trim();
    const email = addEmp.email.trim().toLowerCase();
    const password = addEmp.password;

    if (!name) return alert("Employee name is required.");
    if (!email) return alert("Employee email is required.");
    if (!email.includes("@")) return alert("Please enter a valid email.");
    if (!password || password.length < 4) return alert("Password must be at least 4 characters (MVP).");

    // Prevent duplicates (case-insensitive)
    const exists = allUsers.some((u) => u.email.trim().toLowerCase() === email);
    if (exists) return alert("That email already exists.");

    const now = new Date().toISOString();

    // Managers/Admin can ONLY create employees via this UI
    const newUser: User = {
      id: id("u"),
      name,
      email,
      password,
      role: "employee",
      status: "active",
      createdAt: now,
      // Track ownership so manager only sees their own employees
      ...( { createdBy: user.id } as any ),
    };

    Storage.saveUsers([newUser, ...allUsers]);
    setAddEmp({ name: "", email: "", password: "" });
    refresh();
    alert("Employee added."); };
  // --------------------------------------------------------------

  // ---------------- Users tab: staged edits ----------------
  const [userEdits, setUserEdits] = useState<
    Record<string, { name: string; email: string; phone?: string; role: User["role"]; status: User["status"] }>
  >({});

  const getEditForUser = (u: User) => {
    const draft = userEdits[u.id];
    return {
      name: draft?.name ?? u.name ?? "",
      email: draft?.email ?? u.email ?? "",
      role: (draft?.role ?? u.role) as User["role"],
      status: (draft?.status ?? u.status) as User["status"],
      phone: (draft?.phone ?? (u as any).phone ?? ""),
    };
  };

  const setEditForUser = (
    userId: string,
    patch: Partial<{ name: string; email: string; phone?: string; role: User["role"]; status: User["status"]; }>
  ) => {
    setUserEdits((prev) => ({
      ...prev,
      [userId]: {
        ...(prev[userId] ?? {}),
        ...patch,
      },
    }));
  };

  const setEditRole = (u: User, role: User["role"]) => {
    const cur = getEditForUser(u);
    setEditForUser(u.id, { ...cur, role });
  };

  const setEditStatus = (u: User, status: User["status"]) => {
    const cur = getEditForUser(u);
    setEditForUser(u.id, { ...cur, status });
  };

  const setEditName = (u: User, name: string) => {
    const cur = getEditForUser(u);
    setEditForUser(u.id, { ...cur, name });
  };

  const setEditPhone = (u: User, phone: string) => {
    const cur = getEditForUser(u);
    setEditForUser(u.id, { ...cur, phone });
  };

const applyUserEdits = (u: User) => {
    // Permission gate
    if (!isAdmin) {
      if (!canManageUserRecord(u)) {
        alert("Managers can only update employees they created.");
        return;
      }
    }

    // Managers cannot promote to manager/admin; force role to employee
    const e = getEditForUser(u);
    const safeRole: User["role"] = isAdmin ? (e.role as User["role"]) : "employee";

    // Duplicate email protection (if email changed)
    const nextEmail = e.email.trim().toLowerCase();
    if (nextEmail && nextEmail !== u.email.trim().toLowerCase()) {
      const taken = allUsers.some((x) => x.id !== u.id && x.email.trim().toLowerCase() === nextEmail);
      if (taken) return alert("That email is already in use.");
    }

    const dirty = e.name !== u.name || e.email !== u.email || safeRole !== u.role || e.status !== u.status;
    if (!dirty) return;

    const next = allUsers.map((x) =>
      x.id === u.id
        ? {
            ...x,
                              phone: (e.phone || "").trim() || undefined,

            name: e.name.trim() || x.name,
            email: e.email.trim() || x.email,
            role: safeRole,
            status: e.status,
          }
        : x
    );

    Storage.saveUsers(next);

    // Clear staged edits for this user
    setUserEdits((prev) => {
      const copy = { ...prev };
      delete copy[u.id];
      return copy;
    });

    refresh();
  };
  // --------------------------------------------------------

  const [taskForm, setTaskForm] = useState<{
    id?: string;
    title: string;
    description: string;
    category: string;
    defaultDurationMins: string;
  }>({ title: "", description: "", category: "", defaultDurationMins: "" });

  const [assignForm, setAssignForm] = useState<{
    employeeId: string;
    taskId: string;
    dueDate: string;
    notes: string;
  }>({
    employeeId: employees[0]?.id || "",
    taskId: tasks[0]?.id || "",
    dueDate: new Date().toISOString().slice(0, 10),
    notes: "",
  });

  const setUserStatus = (userId: string, status: User["status"]) => {
    const target = allUsers.find((u) => u.id === userId);
    if (!target) return;

    // Managers can only approve/disable their own created employees
    if (!isAdmin) {
      if (!canManageUserRecord(target)) {
        alert("Managers can only approve/disable employees they created.");
        return;
      }
    }

    const next = allUsers.map((u) => (u.id === userId ? { ...u, status } : u));
    Storage.saveUsers(next);
    refresh();
  };

  const upsertTask = () => {
    if (!taskForm.title.trim()) return alert("Task title is required.");

    const now = new Date().toISOString();
    const mins = taskForm.defaultDurationMins ? Number(taskForm.defaultDurationMins) : undefined;
    if (taskForm.defaultDurationMins && (Number.isNaN(mins) || (mins ?? 0) < 0)) {
      return alert("Duration must be a valid number.");
    }

    if (taskForm.id) {
      const next = tasks.map((t) =>
        t.id === taskForm.id
          ? {
              ...t,
              title: taskForm.title.trim(),
              description: taskForm.description.trim() || undefined,
              category: taskForm.category.trim() || undefined,
              defaultDurationMins: mins,
              updatedAt: now,
            }
          : t
      );
      Storage.saveTasks(next);
    } else {
      const newTask: Task = {
        id: id("t"),
        title: taskForm.title.trim(),
        description: taskForm.description.trim() || undefined,
        category: taskForm.category.trim() || undefined,
        defaultDurationMins: mins,
        createdBy: user.id,
        createdAt: now,
      };
      Storage.saveTasks([newTask, ...tasks]);
    }

    setTaskForm({ title: "", description: "", category: "", defaultDurationMins: "" });
  };

  const editTask = (t: Task) => {
    setTaskForm({
      id: t.id,
      title: t.title,
      description: t.description || "",
      category: t.category || "",
      defaultDurationMins: t.defaultDurationMins?.toString() || "",
    });
    setTab("tasks");
  };

  const deleteTask = (taskId: string) => {
    const t = tasks.find((x) => x.id === taskId);
    if (!t) return;

    if (t.createdBy === "system") {
      alert("System tasks are locked in this MVP. You can edit them, but not delete them.");
      return;
    }

    if (!confirm("Delete this task?")) return;

    Storage.saveTasks(tasks.filter((x) => x.id !== taskId));
    Storage.saveAssignments(assignments.filter((a) => a.taskId !== taskId));
  };

  const createAssignment = () => {
    if (!assignForm.employeeId || !assignForm.taskId) return alert("Pick an employee and a task.");

    const now = new Date().toISOString();
    const newA: Assignment = {
      id: id("a"),
      employeeId: assignForm.employeeId,
      taskId: assignForm.taskId,
      dueDate: assignForm.dueDate || undefined,
      notes: assignForm.notes.trim() || undefined,
      status: "assigned",
      createdAt: now,
    };

    Storage.saveAssignments([newA, ...assignments]);
    setAssignForm({ ...assignForm, notes: "" });
  };

  const removeAssignment = (assignmentId: string) => {
    const a = assignments.find((x) => x.id === assignmentId);
    if (!a) return;

    if (!isAdmin) {
      const emp = allUsers.find((u) => u.id === a.employeeId);
      if (!emp || !canManageUserRecord(emp)) {
        alert("Managers can only remove assignments for employees they created.");
        return;
      }
    }

    Storage.saveAssignments(assignments.filter((x) => x.id !== assignmentId));
  };

  const employeeAssignments = (employeeId: string) =>
    assignments
      .filter((a) => a.employeeId === employeeId)
      .map((a) => ({ ...a, task: tasks.find((t) => t.id === a.taskId) }));

  return (
    <div className="container">
      <div className="card">
        <h2 style={{ marginTop: 0 }}>{isAdmin ? "Admin Dashboard" : "Manager Dashboard"}</h2>
        <small className="muted">
          {isAdmin
            ? "Full access: approvals, users, tasks, assigning, and all-employee sheets."
            : "Manager access: only employees you created, their approvals, assignments, and sheets."}
        </small>

        <hr />

        

        
        
        {tab === "approvals" && (
          <div>
            <h3 style={{ marginTop: 0 }}>Pending sign-ups</h3>

            {pending.length === 0 ? (
              <p>No pending accounts.</p>
            ) : (
              <table className="table">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Email</th>
                    <th>Phone</th>
                    <th>User</th>
                    <th>Created</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {pending.map((u) => (
                    <tr key={u.id}>
                      <td>
                        <b>{u.name}</b>
                      </td>
                      <td>{u.email}</td>
                      <td>{u.phone || "—"}</td>
                      <td>{u.role}</td>
                      <td>{new Date(u.createdAt).toLocaleString()}</td>
                      <td style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
                        <span className="muted">—</span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}

            {!isAdmin && (
              <div className="muted" style={{ marginTop: 10, fontSize: 13 }}>
                Managers only see pending employees created under their own profile.
              </div>
            )}
          </div>
        )}

{tab === "users" && (
          <div>
            <h3 style={{ marginTop: 0 }}>User management</h3>

            {/* Add Employee (looks like admin tooling; employee-only) */}
            <div className="card" style={{ marginBottom: 14 }}>
              <h4 style={{ marginTop: 0, marginBottom: 8 }}>Add Employee</h4>
              <div className="muted" style={{ fontSize: 13, marginBottom: 10 }}>
                {isAdmin
                  ? "Creates an employee account. Managers will only see employees they created."
                  : "Creates an employee inside your manager profile (only you + admin can manage them)."}
              </div>

              <div className="row" style={{ gap: 12 }}>
                <div className="col">
                  <label>Name</label>
                  <input
                    value={addEmp.name}
                    onChange={(e) => setAddEmp({ ...addEmp, name: e.target.value })}
                    placeholder="Employee name"
                  />
                </div>

                <div className="col">
                  <label>Email</label>
                  <input
                    value={addEmp.email}
                    onChange={(e) => setAddEmp({ ...addEmp, email: e.target.value })}
                    placeholder="employee@email.com"
                  />
                </div>

                <div className="col">
                  <label>Temp Password (MVP)</label>
                  <input
                    value={addEmp.password}
                    onChange={(e) => setAddEmp({ ...addEmp, password: e.target.value })}
                    placeholder="Set a password"
                  />
                </div>
              </div>

              <div style={{ display: "flex", gap: 10, marginTop: 12, alignItems: "center", flexWrap: "wrap" }}>
                
                
                <div className="badge">User: employee</div>
                <div className="badge">Status: active</div>
              </div>
            </div>

            <table className="table">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Email</th>
                  <th>User</th>
                  <th>Status</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {visibleUsers.map((u) => {
                  // Managers should not even see other manager/admin users (except self)
                  if (!isAdmin && u.role !== "employee" && u.id !== user.id) return null;

                  const e = getEditForUser(u);

                  const dirty =
                    e.name !== u.name ||
                    e.email !== u.email ||
                    (isAdmin ? e.role !== u.role : false) ||
                    e.status !== u.status;

                  const canEditRow = isAdmin ? true : canManageUserRecord(u) && u.role === "employee";

                  return (
                    <tr key={u.id}>
                      <td>
                        <input
                          value={e.name}
                          onChange={(ev) => setEditName(u, ev.target.value)}
                          style={{ width: "100%" }}
                          disabled={!canEditRow}
                        />
                      </td>
                      <td>
                        <input
                          value={e.email}
                          onChange={(ev) =>
                            setUserEdits((prev) => ({
                              ...prev,
                              [u.id]: {
                                ...(prev[u.id] ?? getEditForUser(u)),
                                phone: ev.target.value,
                              },
                            }))
                          }
                        />

                        <label style={{ marginTop: 10 }}>Phone (optional)</label>
                        <input
                          value={e.phone || ""}
                          onChange={(ev) => setEditPhone(u, ev.target.value)}
                          placeholder="(555) 555-5555"
                        />
                      </td>

                      <td>
                        <select
                          value={isAdmin ? (e.role as User["role"]) : "employee"}
                          onChange={(ev) => setEditRole(u, ev.target.value as User["role"])}
                          disabled={!isAdmin} // only admin can change roles
                        >
                          <option value="employee">employee</option>
                          <option value="manager">manager</option>
                          <option value="admin">admin</option>
                        </select>
                      </td>

                      <td>
                        <select
                          value={e.status}
                          onChange={(ev) => setEditStatus(u, ev.target.value as User["status"])}
                          disabled={!canEditRow && !isAdmin}
                        >
                          <option value="pending">pending</option>
                          <option value="active">active</option>
                          <option value="disabled">disabled</option>
                        </select>
                      </td>

                      <td style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
                        

                        
                      </td>
                    </tr>
                  ); })}
              </tbody>
            </table>

            <div className="muted" style={{ marginTop: 10, fontSize: 13 }}>
              {isAdmin
                ? "Admin can view and edit all users, including managers."
                : "Managers can only view and edit employees they created. Managers cannot view/edit other managers."}
            </div>
          </div>

        
        )}


        {tab === "tasks" && (
          <div className="row">
            <div className="col">
              <h3 style={{ marginTop: 0 }}>{taskForm.id ? "Edit task" : "Add a new task"}</h3>

              <label>Title</label>
              <input
                value={taskForm.title}
                onChange={(e) => setTaskForm({ ...taskForm, title: e.target.value })}
              />

              <label>Description</label>
              <textarea
                value={taskForm.description}
                onChange={(e) => setTaskForm({ ...taskForm, description: e.target.value })}
              />

              <label>Category</label>
              <input
                value={taskForm.category}
                onChange={(e) => setTaskForm({ ...taskForm, category: e.target.value })}
                placeholder="Operations, Inventory, Customer..."
              />

              <label>Default duration (minutes)</label>
              <input
                value={taskForm.defaultDurationMins}
                onChange={(e) => setTaskForm({ ...taskForm, defaultDurationMins: e.target.value })}
                placeholder="e.g., 30"
              />

              <div style={{ marginTop: 10 }}>
                <small className="muted">
                  System tasks are prefilled and can be edited. Only custom tasks can be deleted.
                </small>
              </div>
            </div>

            <div className="col">
              <h3 style={{ marginTop: 0 }}>Task database</h3>

              <table className="table">
                <thead>
                  <tr>
                    <th>Task</th>
                    <th>Category</th>
                    <th>Created by</th>
                    <th>Actions</th>
                  </tr>
                </thead>

                <tbody>
                  {tasks.map((t) => (
                    <tr key={t.id}>
                      <td>
                        <b>{t.title}</b>
                        {t.description && (
                          <div>
                            <small className="muted">{t.description}</small>
                          </div>
                        )}
                      </td>

                      <td>{t.category || "—"}</td>
                      <td>{t.createdBy === "system" ? "system" : "user"}</td>

                      <td style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
                        <span className="muted">—</span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>

              {!isAdmin && (
                <div className="muted" style={{ marginTop: 10, fontSize: 13 }}>
                  Managers can manage the task database, but they can only assign to employees they created.
                </div>
              )}
            </div>
          </div>
        )}


        {tab === "assign" && (
          <div>
            <h3 style={{ marginTop: 0 }}>Assign a task</h3>

            <label>Employee</label>
            <select
              value={(assignForm as any).employeeId || ""}
              onChange={(e) =>
                setAssignForm({ ...(assignForm as any), employeeId: e.target.value })
              }
            >
              <option value="">Select an employee…</option>
              {employees.map((emp: any) => (
                <option key={emp.id} value={emp.id}>
                  {emp.name}
                </option>
              ))}
            </select>

            <label style={{ marginTop: 10 }}>Task</label>
            <select
              value={(assignForm as any).taskId || ""}
              onChange={(e) =>
                setAssignForm({ ...(assignForm as any), taskId: e.target.value })
              }
            >
              <option value="">Select a task…</option>
              {tasks.map((t: any) => (
                <option key={t.id} value={t.id}>
                  {t.title}
                </option>
              ))}
            </select>

            <div style={{ display: "flex", gap: 10, marginTop: 12 }}>
              <button
                className="btn-primary"
                onClick={() => {
                  alert("Assign wiring will be re-added next (this block is compile-safe).");
                }}
              >
                Assign
              </button>

              <button
                className="btn-ghost"
                onClick={() => {
                  setAssignForm({ ...(assignForm as any), employeeId: "", taskId: "" });
                }}
              >
                Clear
              </button>
            </div>

            <div className="muted" style={{ marginTop: 10, fontSize: 13 }}>
              This is a safe placeholder Assign UI to restore compilation. Next we’ll re-add your real assign logic.
            </div>
          </div>
        )}

{tab === "all" && (
          <div>
            <h3 style={{ marginTop: 0 }}>Assignment Sheets</h3>
            <div className="muted" style={{ marginBottom: 12 }}>
              {isAdmin ? "All employees are listed below." : "Only employees created under your manager profile are listed below."}
            </div>

            {employees.length === 0 ? (
              <div className="card">No active employees found.</div>
            ) : (
              <div style={{ display: "flex", flexDirection: "column", gap: 14 }}>
                {employees.map((emp) => {
                  const empAssignments = assignments
                    .filter((a) => a.employeeId === emp.id)
                    .map((a) => {
                      const t = tasks.find((x) => x.id === a.taskId);
                      return {
                        ...a,
                        taskTitle: t?.title || "(task missing)",
                        taskCategory: (t as any)?.category || "—",
                        taskDescription: (t as any)?.description || "—",
                      };
                    })
                    .sort((a, b) => (a.dueDate || "").localeCompare(b.dueDate || ""));

                  const pdfRows = empAssignments.map((a) => ({
                    title: a.taskTitle,
                    category: a.taskCategory,
                    description: a.taskDescription,
                    dueDate: a.dueDate || "—",
                    notes: a.notes || "—",
                    status: a.status || "assigned",
                  }));

                  return (
                    <div key={emp.id} className="card">
                      <div style={{ display: "flex", justifyContent: "space-between", gap: 12, alignItems: "baseline" }}>
                        <div>
                          <h3 style={{ marginTop: 0, marginBottom: 6 }}>{emp.name}</h3>
                          <div className="muted" style={{ fontSize: 13 }}>
                            {emp.email}
                          </div>
                        </div>

                        <div className="badge">Employee</div>
                      </div>

                      <hr />

                      {empAssignments.length === 0 ? (
                        <div className="muted">No assignments for this employee.</div>
                      ) : (
                        <table className="table">
                          <thead>
                            <tr>
                              <th>Task</th>
                              <th>Due</th>
                              <th>Notes</th>
                              <th>Status</th>
                            </tr>
                          </thead>
                          <tbody>
                            {empAssignments.map((a) => (
                              <tr key={a.id}>
                                <td>
                                  <b>{a.taskTitle}</b>
                                  <div>
                                    <small className="muted">
                                      {a.taskCategory}
                                      {a.taskDescription !== "—" ? ` • ${a.taskDescription}` : ""}
                                    </small>
                                  </div>
                                </td>
                                <td>{a.dueDate || "—"}</td>
                                <td>{a.notes || "—"}</td>
                                <td>{a.status}</td>
                              </tr>
                          </tbody>
                        </table>

                      <div className="no-print" style={{ display: "flex", justifyContent: "flex-end", marginTop: 14 }}>
                        <ViewAssignmentsPdfButton
                          employeeId={emp.id}
                          employeeName={emp.name}
                          employeeEmail={emp.email}
                          rows={pdfRows}
                          className="btn-primary"
                          label="View PDF"
                        />
                      </div>
                    </div>
                  );
                })}
              </div>
          </div>
      </div>
    </div>
  );
}
